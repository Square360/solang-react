{"version":3,"sources":["app/store/hooks.ts","lib/solang/filters/FacetFilter.ts","lib/solang/filters/filter.ts","lib/solang/store/solang.slice.ts","lib/solang/filters/SimpleFilter.ts","lib/solang/filters/SimplePager.ts","lib/solang/filters/Sort.ts","app/utils/components/PrettyPrintJson/PrettyPrintJson.tsx","lib/solang/components/SimplePager/SimplePager.tsx","lib/solang/components/SortSelect/SortSelect.tsx","lib/solang/components/FacetCheckbox/FacetCheckbox.tsx","app/components/TestSolang/TestSolang.tsx","app/App.tsx","lib/solang/solang.api.ts","lib/solang/store/solang.epic.ts","app/store/store.ts","serviceWorker.ts","index.tsx"],"names":["useAppDispatch","useDispatch","useAppSelector","useSelector","facetFilterProcessParams","filterState","params","selected","alias","config","Array","isArray","hasValue","value","filterProcessParams","facetFilterProcessQuery","query","excludeTag","push","solrField","sortAlpha","legacy","missingLabel","limit","toString","minCount","undefined","facetFilterAddFacetField","length","join","isOr","options","map","option","facetFilterGetMissingFragment","facetFilterProcessOption","fq","facetFilterAddQuery","facetFilterGetCountsFromAppState","app","filterAlias","filter","getFilterFromApp","facetOptions","forEach","response","facet_counts","facet_fields","counts","Object","keys","count","sort","a","b","getAppFromState","state","appId","apps","console","log","getFilterFromState","filters","id","SolangSlice","createSlice","name","initialState","reducers","createApp","action","payload","Error","q","facet","fl","start","rows","setParams","setQuery","setParam","key","buildQuery","lastQuery","sendQuery","resultsReceived","processFacetFilter","processSimpleFilter","simpleFilterProcessParams","field","simpleFilterProcessQuery","processPager","filterId","parseInt","simplePagerProcessParams","processSort","sortProcessParams","sortItem","find","i","default","label","sortProcessQuery","actions","SolangReducer","reducer","PrettyPrintJson","props","className","data","JSON","stringify","SimplePager","next","prev","CLASS","dispatch","solang","numFound","getCountFromResponse","currentPage","numPages","Math","ceil","isEnd","isStart","onClick","val","SortSelect","onChange","e","el","currentTarget","item","FacetCheckbox","facetCounts","searchState","changeHandler","newState","target","checked","includes","v","index","type","TestSolang","APP_ID","searchApp","results","docs","facetCountsCountry","searchParameter","useState","getSearchString","setSearchString","offset","htmlFor","defaultValue","preventDefault","first_name_s","last_name_s","App","useQueryParams","searchText","withDefault","StringParam","country","ArrayParam","city","page","queryParams","searchFilters","processQueryActions","endpoint","process","prepareQuery","wt","json","SolangEpic","combineEpics","action$","state$","pipe","tap","switchMap","processActions","actionType","newAction","ofType","urlParams","URLSearchParams","entries","arrayValue","append","queryUrl","ajax","crossDomain","headers","url","method","createSolrQueryObs","epicMiddleware","createEpicMiddleware","store","configureStore","middleware","run","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","ReactRouterRoute","Route","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.a0d92de4.chunk.js","sourcesContent":["import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import { filterProcessParams, IFacetOption, IFilterState } from \"./filter\";\nimport {ISolangApp, ISolangParamList, ISolrQuery, SolangState} from \"../solang.types\";\nimport {getAppFromState, getFilterFromApp, getFilterFromState} from \"../store/solang.slice\";\n\nexport interface IFacetFilterConfig {\n  // solrField determines the field which will be filtered\n  solrField: string;\n  // alias is used both as the key for this filter's values in parameter lists and the tag in solr queries (which\n  // gives us greater control over the query)\n  alias: string;\n  // Label used in legend element\n  label: string\n  // Maps to the solr option {!ex=tagname} see: https://solr.apache.org/guide/7_0/faceting.html#tagging-and-excluding-filters\n  excludeTag: boolean;\n  // If false, will be sorted numerically by count (facet.sort)\n  sortAlpha: boolean;\n  // Limit the number of possible facets returned (facet.limit)\n  limit: number;\n  // Limit returned facets by the count (facet.mincount)\n  minCount: number;\n  // If true will combine multiple options using logical OR when filtering results\n  isOr?: boolean;\n  // If provided, an extra facet option will be created representing documents with NO VALUE for the field. The string\n  // will be used as the label for the facet option. (facet.missing)\n  missingLabel?: string;\n};\n\nexport interface IFacetFilterState extends IFilterState {\n  // Filter config\n  config: IFacetFilterConfig;\n  // The currently filter value\n  value: string[];\n  // The available facetOptions\n  options: IFacetOption[];\n  // Boolean indicating whether filter has a selected value - ToDo: do we need hasValue?\n  hasValue: boolean\n}\n\nexport const facetFilterProcessParams = function (filterState: IFacetFilterState, params: ISolangParamList) {\n  filterProcessParams(filterState, params);\n}\n\nexport const facetFilterProcessQuery = function (filterState: IFacetFilterState, query: ISolrQuery) {\n  facetFilterAddFacetField(filterState.config, query);\n  facetFilterAddQuery(filterState, query);\n}\n\n/**\n * Given a filter config & solr query, add the arguments which will request facet options\n * @param query\n */\nexport function facetFilterAddFacetField ( config: IFacetFilterConfig, query: ISolrQuery ) {\n\n  if ( config.excludeTag === true ) {\n    query['facet.field'].push( `{!ex=${config.alias}}${config.solrField}` );\n  }\n  else {\n    query['facet.field'].push( `${config.solrField}` );\n  }\n\n  if ( config.sortAlpha ) {\n    query.legacy[`f.${config.solrField}.facet.sort`] = 'index';\n  }\n\n  if ( config.missingLabel ) {\n    query.legacy[`f.${config.solrField}.facet.missing`] = 'true';\n  }\n\n  if ( config.limit ) {\n    query.legacy[`f.${config.solrField}.facet.limit`] = config.limit.toString();\n  }\n\n  if ( config.minCount ) {\n    query.legacy[`f.${config.solrField}.facet.mincount`] = (config.minCount === undefined) ? '1' : config.minCount.toString();\n  }\n}\n\n\nexport function facetFilterAddQuery (filterState: IFacetFilterState, query: ISolrQuery) {\n\n  if (filterState.value.length > 0) {\n    const join = (filterState.config.isOr === true) ? ' OR ' : ' ';\n\n    const options = filterState.value.map(\n      option => facetFilterProcessOption(filterState.config, option)\n    ).join(join);\n\n    query.fq.push(`{!tag='${filterState.config.alias}'}${options}`);\n  }\n\n}\n\n/**\n * Processes an option value before adding to query (converts to empty if required)\n * @param option\n */\nfunction facetFilterProcessOption (config: IFacetFilterConfig, option: string) {\n  if ( config.missingLabel && option === config.missingLabel) {\n    return facetFilterGetMissingFragment(config);\n  }\n  return `(${config.solrField}:\"${option}\")`;\n}\n\n\n/**\n * Returns the equivalent filter fragment for selecting items without a value.\n */\nfunction facetFilterGetMissingFragment (config: IFacetFilterConfig) {\n  return `(*:* NOT ${config.solrField}:*)`;\n}\n\nexport interface IFormattedFacetOption {value: string, count: number};\n\n/**\n * Returns possible facet options for the given filter.\n * @param state\n * @param appId\n * @param filterAlias\n */\nexport const facetFilterGetCountsFromState = (state: SolangState, appId: string, filterAlias: string): IFormattedFacetOption[] => {\n  const app = getAppFromState(state, appId);\n  return facetFilterGetCountsFromAppState(app, filterAlias);\n}\n\n\n\nexport const facetFilterGetCountsFromAppState = (app: ISolangApp, filterAlias: string): IFormattedFacetOption[] => {\n  const filter = getFilterFromApp(app, filterAlias);\n  let facetOptions: { [key: string]: number } = {};\n\n  // Add pre-selected values into array\n  filter.value.forEach((value: string) => {\n    facetOptions[value] = 0;\n  });\n\n  // Add returned facet options into array\n  if (app.response && app.response.facet_counts ) {\n    const solrField: string = filter.config.solrField;\n    if (app.response.facet_counts.facet_fields[solrField]) {\n      const counts = app.response.facet_counts.facet_fields[solrField];\n      Object.keys(app.response.facet_counts.facet_fields[solrField]).forEach( (value: string) => {\n        facetOptions[value] = counts[value];\n      });\n    }\n  }\n\n  const formattedFacetOptions: IFormattedFacetOption[] = Object.keys(facetOptions).map( (value: string) => {\n    return {value: value, count: facetOptions[value]}\n  });\n\n  const sortedFacetOptions: IFormattedFacetOption[] = formattedFacetOptions.sort( (a: IFormattedFacetOption, b: IFormattedFacetOption) => {\n\n    if (filter.config.sortAlpha) {\n      if (a.value < b.value) return -1;\n      else if (a.value < b.value) return 1;\n      else return 0;\n    }\n    else {\n      if (a.count < b.count) return -1;\n      else if (a.count < b.count) return 1;\n      else return 0;\n    }\n  });\n\n  return sortedFacetOptions;\n}\n","import { ISolangParamList, ISolrQuery } from \"../solang.types\";\nimport { IFacetFilterState } from \"./FacetFilter\";\n\nexport interface IFacetOption {\n  value: string;\n  count: number;\n}\n\nexport interface IFilterState {\n  // Filter config\n  config: any;\n  // Contains a list ofn actions which should be executed on this filter during query process\n  processQueryActions: string[];\n  //\n  value?: any\n}\n\nexport interface IParamProcessor {\n  processParams(params: ISolangParamList): void;\n}\n\n/**\n * @param query\n */\nexport interface IQueryProcessor {\n  processQuery(query: ISolrQuery): void;\n}\n\n/**\n * Updates internal filter state in response to changes in parameters\n * @param filterState\n * @param params\n */\nexport const filterProcessParams = function (filterState: IFacetFilterState, params: ISolangParamList) {\n\n  const alias = filterState.config.alias;\n  let selected: string[];\n\n  if ( Array.isArray(  params[ alias ] ) ) {\n    selected = params[ alias ] as string[];\n    filterState.hasValue = true;\n  }\n  else if ( params[ alias ] ) {\n    selected = [ params[ alias ] ] as string[];\n    filterState.hasValue = true;\n  }\n  else {\n    selected = [];\n    filterState.hasValue = false;\n  }\n\n  filterState.value = selected;\n}\n\n\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport {ISolangApp, ISolangParamList, SolangState, ISolrQuery, ISolrResponse, ISolangAppConfig} from \"../solang.types\";\nimport { facetFilterProcessParams, facetFilterProcessQuery, IFacetFilterState } from \"../filters/FacetFilter\";\nimport { simpleFilterProcessParams, simpleFilterProcessQuery } from \"../filters/SimpleFilter\";\nimport { IFilterState } from \"../filters/filter\";\nimport { ISimplePagerState, simplePagerProcessParams, simplePagerProcessQuery } from \"../filters/SimplePager\";\nimport { ISortState, sortProcessParams, sortProcessQuery } from \"../filters/Sort\";\n\n//////////////////////////////////////\n// Helper Functions\n//////////////////////////////////////\n\n/**\n * Returns a reference to the app with the given appId in the given state, throwing an error if none found.\n * @param state\n * @param appId\n */\nexport const getAppFromState = (state: SolangState, appId: string) => {\n  let app = state.apps[appId];\n  if (!app) {\n    // ToDo: Throw Error\n    // throw new Error(`App ${appId} doesn't exist!`);\n    console.log(`App ${appId} doesn't exist!`);\n  }\n  return app;\n}\n\n/**\n * Returns a filter state from the solr slice\n * @param state\n * @param appId\n * @param filterAlias\n */\nexport const getFilterFromState = (state: SolangState, appId: string, filterAlias: string) => {\n  const app = getAppFromState(state, appId);\n  return getFilterFromApp(app, filterAlias)\n}\n\nexport const getFilterFromApp = (app: ISolangApp, filterAlias: string) => {\n  const filter = app.filters[filterAlias] ?? null;\n  if (!filter) {\n    console.log(`Filter ${filterAlias} on app ${app.id} doesn't exist!`);\n  }\n  return filter;\n\n}\n\nexport const createEmptySolrQuery = (): ISolrQuery => {\n  return {\n    q: '*',\n    facet: 'true',\n    'facet.field': [],\n    fq: [],\n    legacy: {},\n    fl: [],\n    start: 0,\n    rows: 10\n  }\n}\n\nexport interface ISolangState {\n  solang: SolangState\n}\n\n\n//////////////////////////////////////\n// Action & Payload interfaces\n//////////////////////////////////////\n\n/**\n * Interfaces\n */\n\nexport interface ICreateAppPayload {\n  id: string;\n  endpoint: string;\n  config?: ISolangAppConfig,\n  params: ISolangParamList, // url-like paramerers\n  filters: { [key: string]: IFilterState }; // A definition of all filters keyed by alias\n}\n\nexport interface ISetParamsPayload {\n  appId: string,\n  params: ISolangParamList\n}\n\nexport interface ISetParamPayload {\n  appId: string,\n  key: string,\n  value: string | string[]\n}\n\nexport interface IBuildQueryPayload {\n  appId: string,\n  query: ISolrQuery\n}\n\nexport interface iSendQueryPayload {\n  appId: string;\n  query: ISolrQuery;\n}\n\nexport interface IResultsReceivedPayload {\n  appId: string;\n  results: ISolrResponse;\n}\n\nexport interface IProcessFilterPayload {\n  appId: string;\n  filter: string;\n}\n\n\n//////////////////////////////////////\n// Solang Slice\n//////////////////////////////////////\n\nconst initialState: SolangState = {\n  config: {},\n  apps: {},\n};\n\n\nexport const SolangSlice = createSlice({\n  name: 'solang',\n  initialState,\n  reducers: {\n\n    //////////////////////////////////////\n    // Application reducers\n    //////////////////////////////////////\n\n    /**\n     * Create a solr application\n     * @param state\n     * @param action\n     */\n    createApp: (state: SolangState, action: PayloadAction<ICreateAppPayload>) => {\n\n      if (!state.apps[action.payload.id]) {\n        state.apps[action.payload.id] = {\n          ...action.payload,\n          query: createEmptySolrQuery(),\n        };\n\n      } else {\n        throw Error(`Solang app ${action.payload.id} already exists!`);\n      }\n    },\n\n    //////////////////////////////////////\n    // Query lifecycle reducers\n    //////////////////////////////////////\n\n    /**\n     * Set an application's parameters (eg when a user selects a search option)\n     * @param state\n     * @param action\n     */\n    setParams: (state: SolangState, action: PayloadAction<ISetParamsPayload>) => {\n      const appId = action.payload.appId;\n      const app: ISolangApp = state.apps[appId];\n      app.params = action.payload.params;\n\n      if (app?.config?.setQuery) {\n        app.config.setQuery(app.params, 'push');\n      }\n    },\n\n    /**\n     * Update a single parameter in an application\n     * @param state\n     * @param action\n     */\n    setParam: (state: SolangState, action: PayloadAction<ISetParamPayload>) => {\n      const appId = action.payload.appId;\n      const app: ISolangApp = state.apps[appId];\n      app.params[action.payload.key] = action.payload.value;\n      if (app?.config?.setQuery) {\n        app.config.setQuery(app.params);\n      }\n    },\n\n    /**\n     * Usually triggered after params have been changed. Resets an application query. buildQueryEpic will execute\n     * filter process functions to build the query before updating via sendQuery.\n     * @param state\n     * @param action\n     */\n    buildQuery: (state: SolangState, action: PayloadAction<IBuildQueryPayload>) => {\n      console.log('buildQuery reducer', action);\n      console.log('Setting URL params');\n\n\n      const app = getAppFromState(state, action.payload.appId)\n      app.lastQuery = app.query || {};\n      app.query = createEmptySolrQuery();\n    },\n\n    /**\n     * Stores a query. sendQueryEpic will then initiate the solr request and store result in resultsReceived\n     * @param state\n     * @param action\n     */\n    sendQuery: (state: SolangState, action: PayloadAction<iSendQueryPayload>) => {\n      console.log('sendQuery reducer', action);\n    },\n\n    /**\n     * Updates results from a solr query to the application state\n     * @param state\n     * @param action\n     */\n    resultsReceived: (state: SolangState, action: PayloadAction<any>) => {\n      console.log('resultsReceived', action);\n      const app = state.apps[action.payload.appId];\n      app.response = action.payload.response.response;\n    },\n\n    //////////////////////////////////////\n    // Filter reducers\n    //////////////////////////////////////\n\n    /**\n     * processQueryFacet reducer.\n     * @param state\n     * @param action\n     */\n    processFacetFilter: (state: SolangState, action: PayloadAction<IProcessFilterPayload>) => {\n      let app = getAppFromState(state, action.payload.appId);\n      if (app) {\n        facetFilterProcessParams(app.filters[action.payload.filter] as IFacetFilterState, app.params);\n        facetFilterProcessQuery(app.filters[action.payload.filter] as IFacetFilterState, app.query || createEmptySolrQuery());\n      }\n    },\n\n    /**\n     * processSimpleFilter reducer\n     * @param state\n     * @param action\n     */\n    processSimpleFilter: (state: SolangState, action: PayloadAction<IProcessFilterPayload>) => {\n      let app = getAppFromState(state, action.payload.appId);\n      if (app) {\n        simpleFilterProcessParams(app.filters[action.payload.filter] as IFacetFilterState, app.params);\n        simpleFilterProcessQuery(app.filters[action.payload.filter] as IFacetFilterState, app.query || createEmptySolrQuery());\n      }\n    },\n\n    /**\n     * processSimpleSearch reducer\n     * @param state\n     * @param action\n     */\n    processPager: (state: SolangState, action: PayloadAction<IProcessFilterPayload>) => {\n      let app = getAppFromState(state, action.payload.appId);\n      simplePagerProcessParams(app, action.payload.filter, app.params);\n      simplePagerProcessQuery(app.filters[action.payload.filter] as ISimplePagerState, app.query || createEmptySolrQuery());\n    },\n\n    processSort: (state: SolangState, action: PayloadAction<IProcessFilterPayload>) => {\n      let app = getAppFromState(state, action.payload.appId);\n      sortProcessParams(app, action.payload.filter, app.params);\n      sortProcessQuery(app.filters[action.payload.filter] as ISortState, app.query || createEmptySolrQuery());\n    }\n  }\n});\n\nexport const {\n  createApp,\n  setParam,\n  setParams,\n  buildQuery,\n  sendQuery,\n  resultsReceived,\n  processFacetFilter,\n  processSimpleFilter,\n  processPager,\n  processSort\n} = SolangSlice.actions;\n\n\nexport const SolangReducer = SolangSlice.reducer;\n\n","import { ISolangParamList, ISolrQuery } from \"../solang.types\";\nimport { IFacetFilterState } from \"./FacetFilter\";\n\nexport function simpleFilterProcessParams (filterState: IFacetFilterState, params: ISolangParamList) {\n  const alias = filterState.config.alias;\n\n  if ( Array.isArray( params[ alias ] ) ) {\n    filterState.value = params[ alias ] as string[];\n    filterState.hasValue = true;\n  }\n  else if ( params[ alias ] ) {\n    filterState.value = [ params[ alias ] as string ];\n    filterState.hasValue = true;\n  }\n  else {\n    filterState.value = [];\n    filterState.hasValue = false;\n  }\n}\n\nexport function simpleFilterProcessQuery (filterState: IFacetFilterState, query: ISolrQuery) {\n  const solrField = filterState.config.solrField;\n  const field = solrField === 'q' ? '' : `${solrField}:`\n  query.q = filterState.hasValue ? `${field}${filterState.value[0]}*` : '*';\n}\n","import { ISolangApp, ISolangParamList, ISolrQuery, SolangState } from \"../solang.types\";\nimport { getAppFromState, getFilterFromApp } from \"../store/solang.slice\";\nimport { IFilterState } from \"./filter\";\n\nexport interface ISimplePagerConfig {\n  rows: number;\n};\n\nexport interface ISimplePagerState extends IFilterState {\n  // Filter config\n  config: ISimplePagerConfig;\n  // The currently filter value\n  value: number;\n}\n\nexport function simplePagerProcessParams (app: ISolangApp, filterId: string, params: ISolangParamList) {\n\n  const filter = getFilterFromApp(app, filterId);\n  const alias = filter.config.alias;\n  let value: any;\n\n  if ( Array.isArray( params[ alias ] ) ) {\n    value = params[ alias ][0];\n  }\n  else if ( params[ alias ] ) {\n    value = params[ alias ];\n  }\n  else {\n    value = 0;\n  }\n\n  filter.value = (typeof value === 'string') ? parseInt(value) : value;\n}\n\nexport function simplePagerProcessQuery (filterState: ISimplePagerState, query: ISolrQuery) {\n  query.start = filterState.value * filterState.config.rows;\n  query.rows = filterState.config.rows;\n}\n\n\nexport function getCountFromResponse (state: SolangState, appId: string) {\n  const app = getAppFromState(state, appId);\n  return app.response?.response.numFound || 0;\n}\n","\nimport { ISolangApp, ISolangParamList, ISolrQuery } from \"../solang.types\";\nimport { getFilterFromApp } from \"../store/solang.slice\";\nimport { IFilterState } from \"./filter\";\n\nexport interface ISortConfig {\n  alias: string;\n  options: Array<{ label: string, value: string}>;\n  default?: string\n};\n\nexport interface ISortState extends IFilterState {\n  // Filter config\n  config: ISortConfig;\n  // The current filter value\n  value?: string;\n}\n\nexport function sortProcessParams (app: ISolangApp, filterId: string, params: ISolangParamList) {\n\n  const filter = getFilterFromApp(app, filterId);\n  const alias = filter.config.alias;\n\n  let value: any;\n\n  if ( Array.isArray( params[ alias ] ) ) {\n    value = params[ alias ][0];\n  }\n  else if ( params[ alias ] ) {\n    value = params[ alias ];\n  }\n  else {\n    value = '';\n  }\n\n  filter.value = value;\n\n}\n\nexport function sortProcessQuery (filterState: ISortState, query: ISolrQuery) {\n  if (filterState.value !== '') {\n    const sortItem = filterState.config.options.find( i => i.value === filterState.value);\n    if (sortItem) {\n      query.sort = sortItem.value;\n    }\n  }\n  else {\n    if (filterState.config.default) {\n      const sortItem = filterState.config.options.find( i => i.label === filterState.config.default);\n      if (sortItem) {\n        query.sort = sortItem.value;\n      }\n    }\n  }\n}\n","import * as React from \"react\"\nimport './PrettyPrintJson.scss';\n\nconst PrettyPrintJson = (props: any) => {\n    return (\n        <div className={'PrettyPrintJson'}>\n          {props.data && (\n            <pre>{ JSON.stringify(props.data, null, 2) }</pre>\n          )}\n        </div>\n  );\n}\n\nexport default PrettyPrintJson;\n","import { useDispatch, useSelector } from \"react-redux\";\nimport { getFilterFromState, ISolangState, setParam } from \"../../store/solang.slice\";\nimport { getCountFromResponse } from \"../../filters/SimplePager\";\n\ninterface MyProps {\n  appId: string\n  alias: string\n  next?: string;\n  prev?: string;\n}\n\n/**\n * Provides checkbox filter for categories with result counts.\n * @param appId\n * @param alias\n * @constructor\n */\nconst SimplePager = ({appId, alias, next='Next', prev='Previous'}: MyProps) => {\n\n  const CLASS = 'solang-pager';\n  const dispatch = useDispatch();\n\n  const filterState = useSelector((state: ISolangState) => getFilterFromState(state.solang, appId, alias));\n  const numFound = useSelector((state: ISolangState) => getCountFromResponse(state.solang, appId));\n\n  const currentPage = filterState.value;\n  const numPages = Math.ceil(numFound / filterState.config.rows);\n\n  const isEnd = currentPage >= (numPages-1);\n  const isStart = currentPage <= 0;\n\n  const nextHandler = () => {\n    const newPage = (currentPage < numPages) ? currentPage+1 : numPages;\n    const val = newPage.toString();\n    dispatch(setParam({appId: appId, key: alias, value: val}));\n  }\n\n  const prevHandler = () => {\n    const newPage = (currentPage > 0) ? currentPage-1 : 0;\n    const val = newPage.toString() ;\n    dispatch(setParam({appId: appId, key: alias, value: val}));\n  }\n\n  return (\n    <div className={CLASS}>\n\n      { !isStart && <button className={`${CLASS}__prev`} onClick={prevHandler}>{prev}</button> }\n      { !isEnd && <button className={`${CLASS}__next`} onClick={nextHandler}>{next}</button> }\n\n    </div>\n\n  );\n\n}\n\nexport default SimplePager;\n","import { useDispatch, useSelector } from \"react-redux\";\nimport { getFilterFromState, ISolangState, setParam } from \"../../store/solang.slice\";\nimport { getCountFromResponse } from \"../../filters/SimplePager\";\nimport { ISortState } from \"../../filters/Sort\";\nimport { ChangeEvent, ChangeEventHandler } from \"react\";\n\ninterface MyProps {\n  appId: string\n  alias: string\n  next?: string;\n  prev?: string;\n}\n\n/**\n * Provides checkbox filter for categories with result counts.\n * @param appId\n * @param alias\n * @constructor\n */\nconst SortSelect = ({appId, alias}: MyProps) => {\n\n  const CLASS = 'sort-select';\n  const dispatch = useDispatch();\n  const filterState = useSelector((state: ISolangState) => getFilterFromState(state.solang, appId, alias)) as ISortState;\n\n\n  const updateHandler = (e: ChangeEvent) => {\n    const el = e.currentTarget as HTMLSelectElement;\n    dispatch(setParam({appId: appId, key: alias, value: el.value}));\n  }\n\n  return (\n    <div className={CLASS}>\n\n      <select className={`${CLASS}__input`} onChange={updateHandler}>\n        { filterState.config.options.map(item => (\n            <option key={item.value} value={item.value} className={`${CLASS}__input`}>{item.label}</option>\n        ))}\n      </select>\n\n    </div>\n\n  );\n\n};\n\nexport default SortSelect;\n","import { useDispatch } from 'react-redux'\nimport {getAppFromState, setParam} from \"../../store/solang.slice\";\nimport {\n  facetFilterGetCountsFromAppState,\n  IFacetFilterState\n} from \"../../filters/FacetFilter\";\nimport { ChangeEvent } from \"react\";\nimport { ISolrFacetField } from \"../../solang.types\";\nimport {useAppSelector} from \"../../../../app/store/hooks\";\nimport {RootState} from \"../../../../app/store/store\";\n\nimport './FacetCheckbox.scss';\n\ninterface MyProps {\n  appId: string,\n  filterState: IFacetFilterState,\n  facetCounts: ISolrFacetField,\n}\n\n/**\n * Provides Checkbox facet filter\n * @param appId\n * @param filterState\n * @param facetCounts\n * @constructor\n */\nconst FacetCheckbox = ({appId, filterState, facetCounts, }: MyProps) => {\n\n  const CLASS = 'facet-cb';\n  const dispatch = useDispatch();\n  const alias = filterState.config.alias;\n\n  const searchState = useAppSelector((state: RootState) => getAppFromState(state.solang, appId) );\n\n  const options = facetFilterGetCountsFromAppState(searchState, alias);\n\n  const changeHandler = (e: ChangeEvent<HTMLInputElement>) => {\n\n    let newState = [...filterState.value];\n    let value = e.target.value;\n\n    if (e.target.checked && !newState.includes(value)) {\n      newState.push(value);\n      dispatch(setParam({appId: appId, key: alias, value: newState}));\n    }\n    else if (!e.target.checked && newState.includes(value)) {\n      dispatch(setParam({appId: appId, key: alias, value: newState.filter(v => v !== value)}));\n    }\n  }\n\n\n  return (\n\n    <div className={`${CLASS}`}>\n      <fieldset>\n        {filterState.config.label && <legend>{filterState.config.label}</legend>}\n\n        <ul className={`${CLASS}__list`}>\n          { options.map( (option, index) => (\n            <li className={`${CLASS}__list-item`} key={`${appId}--${alias}--${index}`}>\n              <label  className={`${CLASS}__label`}>\n                <input\n                  type=\"checkbox\"\n                  checked={filterState.value.includes(option.value)}\n                  onChange={changeHandler}\n                  value={option.value}\n                  name={alias}/> <span className={`${CLASS}__value`}>{option.value}</span>  <span className={`${CLASS}__count`}>({option.count})</span>\n              </label>\n            </li>\n          ))}\n        </ul>\n\n      </fieldset>\n\n\n    </div>\n\n  );\n};\n\n\nexport default FacetCheckbox;\n","import { useState } from 'react';\nimport { useAppSelector, useAppDispatch } from '../../store/hooks';\nimport {\n  getAppFromState, getFilterFromApp,\n  setParams,\n} from '../../../lib/solang/store/solang.slice';\n\nimport { RootState } from \"../../store/store\";\nimport { ISolangParamList } from \"../../../lib/solang/solang.types\";\nimport PrettyPrintJson from \"../../utils/components/PrettyPrintJson/PrettyPrintJson\";\nimport SimplePager from \"../../../lib/solang/components/SimplePager/SimplePager\";\nimport SortSelect from \"../../../lib/solang/components/SortSelect/SortSelect\";\n\nimport './TestSolang.scss';\nimport FacetCheckbox from \"../../../lib/solang/components/FacetCheckbox/FacetCheckbox\";\nimport { IFacetFilterState } from \"../../../lib/solang/filters/FacetFilter\";\n\n\nexport const TestSolang = () => {\n\n  const APP_ID = 'searchApp';\n  const FILTER_KEY = 'searchText';\n  const NUM_ROWS = 10;\n\n\n  const dispatch = useAppDispatch();\n\n  // @ts-ignore\n  const searchApp = useAppSelector((state: RootState) => getAppFromState(state.solang, APP_ID) );\n\n  const results = (searchApp && searchApp.response) ? searchApp.response.response.docs : [];\n\n  const facetCounts = (searchApp && searchApp.response && searchApp.response.facet_counts) ? searchApp.response.facet_counts : [];\n\n  const facetCountsCountry = (\"facet_fields\" in facetCounts)\n    ? facetCounts.facet_fields['country_s']\n    : {};\n\n  const searchParameter = useAppSelector((state: RootState) => {\n    const app = getAppFromState(state.solang, APP_ID);\n    return app ? app.params[FILTER_KEY] : 'undefined';\n  });\n\n  const [getSearchString, setSearchString] = useState(searchParameter);\n\n  const updateParams = (e: any) => {\n    e.preventDefault();\n    const params: ISolangParamList = {...searchApp.params};\n    params[FILTER_KEY] = getSearchString;\n    dispatch(setParams({appId: APP_ID, params: params}));\n  }\n\n  const resetParams = () => {\n    dispatch(setParams({appId: APP_ID, params: {}}));\n  }\n\n  const offset = searchApp.response?.response.start || 0;\n  const numFound = searchApp.response?.response.numFound || 0;\n  const currentPage = Math.ceil(offset / NUM_ROWS);\n  // const numPages = Math.ceil(numFound / NUM_ROWS);\n\n  return (\n    <div className={'TestSolang'}>\n      <PrettyPrintJson data={searchApp.params}/>\n\n\n      <div className={'row'}>\n        <label htmlFor='val'>Param value:</label>\n        <input\n          id='val'\n          aria-label=\"Set increment amount\"\n          defaultValue={searchParameter}\n          onChange={(e) => setSearchString(e.target.value)}\n        />\n\n        <button\n          aria-label=\"Decrement value\"\n          onClick={updateParams}\n        >\n          Set as param\n        </button>\n\n        <button onClick={resetParams}>Reset</button>\n\n      </div>\n\n      <div><strong>Internal param value:</strong> {getSearchString}</div>\n      <div><strong>Solang value:</strong> {searchParameter}</div>\n\n      <FacetCheckbox\n        appId={APP_ID}\n        filterState={getFilterFromApp(searchApp, 'country') as IFacetFilterState}\n        facetCounts={facetCountsCountry}\n        />\n\n      <p>Showing {results.length} of {numFound} results. Page {currentPage}</p>\n\n      <SortSelect appId={APP_ID} alias={'sort'}/>\n      { results && (\n        <ul>\n          {results.map(item => (\n            <li key={item.id}>{item.first_name_s} {item.last_name_s}</li>\n          ))}\n        </ul>\n      )}\n\n      <SimplePager appId={APP_ID} alias={'page'}/>\n\n      <PrettyPrintJson data={searchApp.query}/>\n\n    </div>\n  );\n}\n","import React from 'react';\nimport './App.scss';\nimport { useAppSelector, useAppDispatch } from \"./store/hooks\";\nimport {RootState} from \"./store/store\";\nimport {\n  getAppFromState,\n  createApp,\n  processFacetFilter,\n  processPager,\n  processSimpleFilter,\n  processSort,\n} from \"../lib/solang/store/solang.slice\";\nimport { TestSolang } from \"./components/TestSolang/TestSolang\";\nimport {ArrayParam, StringParam, useQueryParams, withDefault} from \"use-query-params\";\n\nfunction App() {\n\n  const dispatch = useAppDispatch();\n  const searchApp = useAppSelector((state: RootState) => getAppFromState(state.solang, 'searchApp') );\n\n  // Setup listener for query params on route\n  const [queryParams, setQuery] = useQueryParams({\n    searchText: withDefault(StringParam, 'Dav'),\n    country: withDefault(ArrayParam, []),\n    city: withDefault(ArrayParam, []),\n    page: withDefault(StringParam, '0'),\n    sort: withDefault(StringParam, ''),\n  });\n\n  if (!searchApp) {\n    const searchFilters = {\n      searchText: {\n        config: {\n          solrField: 'last_name_t',\n          alias: 'searchText',\n        },\n        processQueryActions: [processSimpleFilter.type],\n        value: queryParams.searchText || ''\n      },\n      country: { // type: facet filter\n        config: {\n          solrField: 'country_s',\n          alias: 'country',\n          label: 'Country',\n          minCount: 1,\n          sortAlpha: true,\n          excludeTag: true\n        },\n        processQueryActions: [\n          processFacetFilter.type\n        ],\n        value: queryParams['country']\n      },\n      city: { // type: facet filter\n        config: {\n          solrField: 'city_s',\n          alias: 'city',\n          label: 'City',\n          sortAlpha: true,\n          minCount: 1\n        },\n        processQueryActions: [processFacetFilter.type],\n        value: queryParams.city\n      },\n      page: {\n        config: {\n          rows: 10,\n          alias: 'page',\n        },\n        processQueryActions: [processPager.type],\n        value: queryParams.page || 0\n      },\n      sort: {\n        config: {\n          alias: 'sort',\n          options: [\n            {label: 'Relevance', value: ''},\n            {label: 'A-Z', value: 'last_name_t asc'},\n            {label: 'Z-A ', value: 'last_name_t desc'},\n          ],\n        },\n        processQueryActions: [processSort.type],\n        value: '',\n      },\n    };\n\n    dispatch(createApp({\n      id: 'searchApp',\n      endpoint: process.env.REACT_APP_SOLR_ENDPOINT as string,\n      config: {\n        setQuery: setQuery\n      },\n      params: queryParams as any,\n      filters: searchFilters,\n    }));\n  }\n\n  // setupQuerySync(store, 'searchApp', Object.keys(searchFilters));\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>Solang Test</h1>\n      </header>\n      <TestSolang></TestSolang>\n    </div>\n  );\n}\n\nexport default App;\n","import { ISolangApp, ISolrQuery } from \"./solang.types\";\n\nimport { ajax } from 'rxjs/ajax';\n\nexport const createSolrQueryObs = function(app: ISolangApp) {\n\n  const query: ISolrQuery = {...app.query};\n\n  const params = prepareQuery(query);\n\n  const urlParams = new URLSearchParams();\n\n  Object.entries(params).forEach(([key, value]) => {\n    if (Array.isArray(value)) {\n      value.forEach(arrayValue => urlParams.append(key, arrayValue))\n    }\n    else {\n      urlParams.append(key, value as string);\n    }\n  });\n\n  const queryUrl = `${app.endpoint}select?${urlParams.toString()}`\n\n  const ajax$ = ajax({\n    crossDomain: true,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    url: queryUrl,\n    method: 'GET',\n  });\n\n  return ajax$;\n}\n\nexport const prepareQuery = function(query: ISolrQuery) {\n\n  const params: any = {...query};\n\n  if (!params.q) params.q = '*';\n\n  // Give us nested list json\n  params.wt = 'json';\n  // Prepare json.facet\n  if (params['json.facet'] && typeof params['json.facet'] === 'object') {\n    const json = JSON.stringify(params['json.facet']);\n    params['json.facet'] = json;\n  }\n\n  if (params.legacy) {\n    Object.keys(params.legacy).forEach( key => {\n      params[key] = params.legacy[key];\n    });\n    delete params.legacy;\n  }\n  /**\n   * json.nl=arrmap will format as [{\"facetValue1\": facetCount1}, {\"facetValue2\": facetCount2}].\n   * json.nl=map will format as {\"facetValue1\": facetCount1, \"facetValue2\": facetCount2}\n   * @type {string}\n   */\n  params['json.nl'] = 'map';\n\n  return params;\n}\n","import {  AnyAction } from \"@reduxjs/toolkit\";\nimport { filter, map, switchMap, tap, takeUntil } from 'rxjs/operators';\nimport { combineEpics, ofType } from \"redux-observable\";\nimport { setParam, setParams, buildQuery, sendQuery, getAppFromState, resultsReceived } from './solang.slice';\nimport { createSolrQueryObs } from \"../solang.api\";\nimport {ISolangApp} from \"../solang.types\";\n\n/**\n * processParamsEpic executes after any actions which change a solr app's parameters.\n * This triggers the buildQuery action which in turn triggers the buildQueryEpic.\n * @param action$\n */\nexport const processParamsEpic = (action$: any, state$: any) => {\n  return action$.pipe(\n    filter((action: any) => {\n      return [\n        setParams.type,\n        setParam.type\n      ].includes(action.type);\n    }),\n    tap(action => console.log('processParamsEpic', action)),\n    tap( (action: AnyAction) => {\n      // Update query parameters\n      const app = getAppFromState(state$.value.solang, action.payload.appId);\n      if (app?.config?.setQuery) {\n        app.config.setQuery(app.params);\n      }\n    }),\n    // If triggering params updates externally, do not trigger buildQuery\n    // filter( (action: AnyAction) => {\n    //   const app = getAppFromState(state$.value.solang, action.payload.appId);\n    //   return (app.config?.externalParams === false)\n    // }),\n    map((action: AnyAction) => {\n\n      return {\n        type: buildQuery.type,\n        payload: {appId: action.payload.appId}\n      }\n    }),\n  );\n}\n\n/**\n *\n * @param action$\n * @param state$\n */\nexport const processQueryEpic = (action$: any, state$: any) => {\n  return action$.pipe(\n\n    filter((action: AnyAction)  => action.type === buildQuery.type),\n    tap(action => console.log('buildQueryEpic starting', action)),\n    switchMap( (action: AnyAction) => {\n\n      // Get the state for this application\n      const app = getAppFromState(state$.value.solang, action.payload.appId);\n      if (!app) {\n        throw new Error('No app ${action.payload.appId} in buildQueryEpic');\n      }\n\n      // Iterate through the filters, run the appropriate reducers for each.\n      const params = app.params;\n      let query = {};\n\n      const processActions = [];\n      Object.keys(app.filters).forEach( key => {\n        app.filters[key].processQueryActions.forEach( actionType => {\n          if (actionType) {\n            // Create a new action with the application & filter\n            const newAction = {\n              type: actionType,\n              payload: {\n                appId: action.payload.appId,\n                filter: key\n              }\n            }\n            processActions.push(newAction);\n          }\n        })\n      });\n\n      processActions.push({\n        type: sendQuery.type,\n        payload: {\n          appId: action.payload.appId,\n          query: query\n        }\n      });\n\n      return processActions;\n    })\n  );\n}\n\n/**\n * sendQueryEpic fires when the solr query has been changed by sendQuery. Any new (sendQuery) action occurring before\n * the current query completes will cancel the current query.\n * @param action$\n * @param state$\n */\nexport const sendQueryEpic = (action$: any, state$: any) => {\n  return action$.pipe(\n    ofType(sendQuery.type),\n    tap(action => console.log('sendQueryEpic', action)),\n    // Switch Map will auto-cancel any previous instance.\n    switchMap( (action: AnyAction) => {\n\n      const app = getAppFromState(state$.value.solang, action.payload.appId);\n      if (app) {\n        return createSolrQueryObs(app).pipe(\n          map(response => {\n            return {\n              type: resultsReceived.type,\n              payload: {\n                appId: action.payload.appId,\n                response: response\n              }\n            }\n          })\n        );\n      }\n      else {\n        throw(new Error('No solang app!'));\n      }\n    })\n  );\n}\n\nexport const SolangEpic = combineEpics(\n  processParamsEpic,\n  // buildQueryEpic,\n  processQueryEpic,\n  sendQueryEpic\n);\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\nimport { createEpicMiddleware } from 'redux-observable';\n\nimport { SolangReducer } from '../../lib/solang/store/solang.slice';\nimport { SolangEpic } from \"../../lib/solang/store/solang.epic\";\n\nconst epicMiddleware = createEpicMiddleware();\n\nexport const store = configureStore({\n  reducer: {\n    solang: SolangReducer\n  },\n  middleware: [\n    epicMiddleware\n  ]\n});\n\nepicMiddleware.run(SolangEpic);\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './app/App';\nimport { store } from './app/store/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\nimport { BrowserRouter as Router, Route } from 'react-router-dom';\nimport { QueryParamProvider } from 'use-query-params';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <Router>\n        <QueryParamProvider ReactRouterRoute={Route}>\n          <App />\n        </QueryParamProvider>\n      </Router>,\n\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}